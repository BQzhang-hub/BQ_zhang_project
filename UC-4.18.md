# 4.18

## 59pm

1. vfork()+execl()方式创建子进程
2. vfork()和fork()在语法上没有区别，唯一的区别在于vfork()不复制父进程的任何资源
3. vfork()直接占用父进程的资源运行代码，父进程处于阻塞状态，直到子进程结束或者调用了exec系列函数（例如：excel()）
4. vfork()+excel()的合作方式：
5. vfork()可以创建新的进程，但是没有代码的数据，excel()创建不了新进程，但是可以为进程提供代码和数据
6. 和fork()不同，vfork()创建子进程后确保子进程先进行
7. 父进程直到子进程调用了excel()之后才能运行。
8. vfork()无法使用return退出
9. vfork()占用父进程资源，必须用exit()退出
10. execl()是exce系列函数中的第一个
11. 功能是启动一个全新进程，替换当前的进程。新的进程会全面覆盖旧进程，但是不会新建进程（会替换各种内存区域，但PID不变）
12. execl("程序的路径","执行命令","选项","参数",NULL)
13. 只有第一个参数是必须正确的，第二个参数必须存在但是可以不正确，第三个和第四个参数可以没有，NULL代表参数结束了。
14. 比如运行我们的程序：excel("./b.out","b.out",NULL)

## 信号

15. 信号：（signal）
16. 信号是unix/Linux系统下最常见的一种 软件 中断方式
17. 中断就是 让程序停止当前正在运行的代码，转而执行其他代码的过程
18. 中断分为软件中断和硬件中断，软件中断就是用软件的方式中断代码
19. 信号导致代码中断的案例很多，比如：
20. ctrl+C  ---> 信号2
21. kill -9----> 信号9
22. 段错误-----> 信号11
23. 总线错误---> 信号7（不确定，不同信号不一定）
24. unix系统信号从1到48，Linux系统从1-64，但是不确保连续，而且 规范中没有规定信号的数量
25. 信号都有一个宏名称，以SIG开头，比如：信号2 叫 SIGINT，本质就是一个非负整数
26. kill -l---查看信号的命令
27. 注：编程时 信号用宏名称，因此有些系统信号数字不同，但是宏名称是一样的
28. 常见的宏名称
29. SIGINT---信号2---ctrl+c
30. SIGQUIT--信号3--ctrl+\
31. SIGLILL--信号9--
32. 在Linux系统中，1-31是不可靠信号，是早期信号，不支持排队，因为可能丢失
33. 34-64 是可靠信号 ，支持排队，不可能丢失
34. 信号分为可靠信号和不可靠信号
35. 信号的处理的方式：信号只是一个整数，实现中断的功能靠信号处理。
36. 信号处理方式有三种：
37.     - 1.默认处理，系统提供的，多半是退出进程
38.     - 2.忽略信号，信号来了不做额外的处理，直接忽略
39.     - 3.自定义处理函数，信号按程序员的代码处理
40. 有些信号是被自定义和忽略的，比如：信号9
41. 进程可以给其他进程发信号，但是只能给本用户的进程发信号，root用户可以所有用户的进程发信号。
42. 作业：写myls命令，功能仿照ls -l:针对文件，显示当前文件的各种信息
43. 针对目录，显示改目录所有子项的详细信息。

----

## 回顾

1. wait()和waitpid()---让父进程等待子进程，直到子进程结束父进程才能继续运行（waitpid()可以设置不等待）
2. wait()是等待任意任意一个子进程的结束（包括僵尸子进程），waitpid()可以设置等待哪些或哪个子进程，也可以设置是否等待。
3. wait()和waitpid()可以取得子进程的退出状态和退出码
4. 进程的退出---主函数return\exit()\_Exit()\信号
5. vfork()+excel()---创建子进程的第二种方式，子进程执行的代码由execl()提供
6. 其实fork()也可以和excel()结合使用，但是vfork()更合适。
7. vfork()确保子进程先进行，因为子进程抢占了父进程的资源，直到excel()或子进程结束后才返还。
8. vfork()创建的子进程必须用exit()显示结束
9. 信号的基础---信号是unix系统中的 一种软件中断的方式
10. 信号可分为可靠信号和不可靠信号，区别是可靠信号支持排队，不会丢失；不可靠信号不支持排队，会丢失。
11. 浮点数可以除以0--结果是INF(无限大)
12. 信号的处理方式：
	>1. 默认处理，大多数都是退出进程
	>2. 忽略，当信号从来没有来过
	>3. 自定义处理函数，注册
13. 信号9 不可忽略 也不可能自定义
14. 当前用户只能给自己的进程发信号，root可以给所有进程发信号

----

## 今天

1. 函数signal()/sigaction()可以设置信号的处理方式
2. signal()使用一个函数指针，原型：void (*f)(int)
3. 函数指针 signal(int 信号值，函数指针);
	> 1. 其中，第二个参数函数指针可以是以下三个值：
		- SIG_IGN---忽略该信号
		- SIG_DFL---恢复默认处理
		- 传入一个程序员自定义函数名--自定义处理函数
	> 2. 返回，成功返回之前的处理方式，失败返回SIG_ERR
	> 3. ==注：==signal()只是设定了信号处理方式，自身并没有发信号，因此信号处理函数在有信号到来时才执行。
4. kill 命令用于发信号，格式：kill -信号 进程PID
5. 信号0 没有实际的意义，用于测试是否有发信号的权限。
6. 使用signal()设置信号的处理方式，其中自定义就是相同的操作，执行的是自己定义的。例如在进程中ctrl+c是结束进程，但是如果使用signal()设置信号2（SIGINT）为自定义处理方式，那么在进程中ctrl+c就执行自定义函数中的内容。

### 父子进程之间的信号处理

1. 如果父进程用fork()创建的子进程，子进程与父进程的信号处理方式完全一致（照抄）。就算父进程结束，子进程还是用fa。
2. 如果父进程用vfork()+execl()方式创建的子进程，父进程自定义处理函数的子进程改为默认（因为子进程已经没有了处理函数），其他照抄。

### 信号的发送方式：

1. 键盘发送
	> ctrl+c----->信号2
	> ctrl+\----->信号3
2. 程序错误（部分信号）
	> 段错误、总线错误、整数被0除
3. kill命令(所有信号)
	> kill -信号 进程PID
4. 系统函数
	> raise() \kill()\alarm()\sigqueue()...
	> 重点是kill(),了解alarm()

### int kill(pid_t pid, int signo)

1. 参数pid制定了给哪些或哪几个进程发信号，和waitpid()中pid一样。signo就是发送信号几。
2. 返回：成功返回0，失败返回-1
3. pid的值：
> 1. 正数：就是给指定的一个进程发信号（pid）
> 2. -1：就是给所有进程发信号（有权限的）
> 3. 0 ： 本组所有的进程发信号
> 4. -1： 指定进程组（组ID=-pid）的所有进程
> 5. 最常用的是正数，其次是-1.
4. killall a.out----杀死所有进程
5. 注意信号kill()和signal()的作用时间，保证在发信号之前signal()已经设定为自定义了。
6. signal()是设定信号的处理方式，kill()是给进程发信号。

### unsigned int alarm(unsigned int seconds);

1. alarm(int n)--->n秒以后产生一个信号，发给本进程
2. alarm()可以做计划任务
3. alarm(0)就是取消闹钟，返回之前的剩余秒数

### sleep()&usleep()

1. sleep()会让程序休眠，直到休眠的时间到，或者有 未忽略的信号到来。会返回剩余的秒数
2. usleep()函数 更精确 休眠是以微妙为单位。

## 512pm

### 信号集

1. 系统定义了存放多个信号的数据结构，就是信号集sigset-t,本质是一个超大的整数，每个二进制位代表一个信号，比如：信号2用倒数第二位代表，倒数第二位是1，代表有信号2，是0代表没有。
2. 信号集的运算结构（提供函数）：
	> 1. 增加元素（信号）
	> 2. 删除元素（信号）
	> 3. 查询元素（信号）
3. 5个函数：
	> 1. 增加---全或单---sigaddset()/增加一个信号（某个二进制置1-----sigfillset()/所有信号全部增加
	> 2. 删除---全或单---sigdelset()/删除一个信号---sigemptyset()/删除所有信号（所有位置0）
	> 3. 查询---sigismember()---查询一个信号是否存在==1
4. 应用场景---银行转账
	> (先信号屏蔽)
	> 1. 先改转出账户，把金额减少
	> (信号来了。。。打断。。。出现错误。。。暂时不处理)
	> 2. 再改转入账户，把金额增加
	> (信号在这里处理)
	> (解除信号的屏蔽)
	> 3. 信号什么时刻来是无法确定和控制的

### 信号屏蔽

1. 信号什么时间来是无法确定和控制的，但可以使用信号屏蔽技术让信号的处理时间延后。
2. 信号屏蔽主要用于关键代码的执行，不是阻止信号的到来，而是将信号的处理延后。
3. 关键执行完毕后 一定要解除信号的屏蔽。
4. 例如上面的4---应用场景
5. sigprocmask()---可以屏蔽/解除屏蔽
6. sigprocmask(int how,sigset_t* new,sigset_t* old)
	> 1. 参数how是信号屏蔽的方式
	> 2. 参数new是新的权限屏蔽字（屏蔽哪些权限）
	> 3. 参数old是传出参数，用于传出以前的信号屏蔽字，便于后面恢复。
	> 4. how的三种方式：
		- SIG_BLOCK:之前的屏蔽+new的屏蔽--->a b c+c d e--->a b c d e
		- SIG_UNBLOCK:之前的屏蔽-new的屏蔽--->a b c-c d e--->a b
		- SIG_SETMASK:直接用新的屏蔽，与之前的无关，最常用---> a b d    c d e--->c d e   
7. 信号1-31：不可靠信号，不支持排队
8. sigaction()的绝大数的功能都由signal()实现，一些特殊的功能sigaction()可以实现。
9. sigcation()可以让信号有更多的信息，甚至可以在发信号的时候 附带额外的数据。
10. 信号的应用---计时器（了解）
> Linux计时器就是N秒以后，每隔M产生一个信号。计数器有三种：真实，虚拟和实用，常用的是真实计数器，真实计数器产生SIGALRM信号

## IPC---进程间通信

1. Unix系统早期都是用多进程解决问题的额，因此多个进程之间需要交互数据。
2. 进程和进程之间不能直接交互数据，IPC就是这个问题。
3. IPC只要包括：
> 1. 文件
> 2. 信号
> 3. 管道（文件）
> 4. 共享内存
> 5. 消息队列
> 6. 信号量集
> 7. 网络socket...
4. 其中，共享内存、消息队列和信号量集都是XSI IPC，遵循相同的规范。因此，编程有很多共性的地方。
5. 管道是最古老的IPC,但目前很少用。


## 513am

### 回顾

1. 信号---信号的处理方式：默认、忽略、自定义处理函数
2. 函数signal()可以设定信号的处理方式。signal()的用法：
> 1. 头文件signal.h
> 2. 写一个处理函数 void fa(int);
> 3. 调用signal()
3. 信号的发送函数：kill()可以给指定的某个、某些进程发信号
4. 信号集sigset_t:用一个二进制位代表一个信号的有无
5. 提供函数：
> sigemptyset()/sigaddset()/sigdelset()/sigismember()/sigfillset()
6. 信号屏蔽---某些执行关键代码时，不希望被信号打断。信号的到来是无法阻止的，但可以暂时不做处理，这种技术叫信号屏蔽。
7. 信号屏蔽使用函数sigprocmask(),也负责解除屏蔽。
8. IPC---进程间通信
> 1. 在通常情况下，进程间不能直接访问，又可以交互数据，所以才有了进程间通信。进程间通信就是多个进程使用相同的媒介交互数据。

### 今天

1. 管道（了解）
2. 管道就是以文件作为交互的媒介，这种文件比较特殊，是管道文件。
3. 管道分为有名管道（有文件名）和无名管道（没有名字）。有名管道就是程序员自己创建管道文件，然后进行交互。无名管道就是系统帮我们创建管道文件，利用系统的管道文件进行交互。
4. 有名管道适用于所有的进程的通信，无名管道只能用于fork()创建的父子进程之间的通信。
5. 有名管道：
	> 管道文件无法用touch/vi/open()创建，创建管道文件需要使用mkfifo命令或者mkfifo()。
	> 管道文件创建完毕后，再读写进行操作实现进程间的通信
	> 管道文件不存储数据，一边写一边读，只是倒一下数据
	> 创建管道文件命令：mkfifo a.pipe
	> 读取管道文件命令：cat a.pipe
	> 写入管道文件命令：ls > a.pipe

### XSI IPC--消息队列 信号量集 内存共享

1. XSI IPC的共性：
> 1. 创建/获取IPC结构（共享内存、消息队列和信号量集）必须先提供一个外部的key.
> 2. 每个IPC结构都有一个唯一的ID与之对应，用key可以拿到id.
> 3. 外部key的类型是key_t,获得key的方式有三种：
	- a. 使用宏IPC_PRIVATE做key,这个key基本不用，因为这个key只能创建，不能获取。（有但是不使用）
	- b. 可以用函数ftok()创建key
	- c. 可以在一个公共头文件中定义每个使用的key,key本身就是一个整数。
> 4. 函数XXXget()可以用key创建/获得ID,比如：shmget()/msgget()
> 5. 每种IPC结构都提供了一个XXXctl()，可以修改、删除、查询IPC结构,是针对于共享内存的结构而言。
> 6. 使用key新建IPC结构时，参数XXXflag一般都是IPC_CREAT|权限
> 7. xxxctl()中，cmd支持以下宏：
	- IPC_STAT:用于查询。
	- IPC_SET:用于修改
	- IPC_RMID:用于删除

##### 共享内存

1. 共享内存---内核管理一片物理内存，允许不同的进程映射，因此多个进程可以映射同一块物理内存。
2. 共享内存 是最快IPC.
3. 映射物理内存叫挂接，用完以后解除映射叫脱接。
4. 共享内存的步骤：
	> 先获得key,可以使用头文件或者ftok()
	> 用key获得/创建一个共享内存的ID,函数shmget()
	> 映射共享内存，挂接，函数shmat()
	> 数据交互。IPC---共享内存就是内存---所有取反数据就是*P=a or (int) *p = shmat()
	> 解除映射，脱接。函数shmdt()
	> 如果确定共享内存不再使用，可以使用shmctl()函数删除
5. IPC结构可以使用命令 查看或者删除：
	> ipcs---可以查询IPC
	> ipcrm---可以删除IPC
	> ipcs -a---查看所有IPC
	>      -m---查看共享内存
	>      -q---查看消息队列
	>      -s---查看信号量集
	> ipcrm删除时，需要提供IPC的ID
6. key_t ftok(const* char *path,key_t ID)通过一个真实存在的路径+项目ID(0-255)生成一个key
7. int shmget(key_t key,size_t size,int flag)
    > size:共享内存的大小
	> flag新建时给IPC_CREAT|权限，获取时给0；
	> flag---IPC_CREAT|IPC_EXCL---不打开返回-1
	> 返回共享内存的ID(shmid),失败返回-1
8. void* shmat(int shmid,const void* shmaddr,int shmflag)---挂接
	> shmid---共享内存
	> 参数2和参数3一般0
	> 返回共享地址的首地址
9. int shmdt(const void* shmaddr)
    > shmaddr就是shmat()的返回值
10. shmctl(int shmid,int cmd,struct shmid_ds *buf)
    cmd:
	- IPC_STAT:用于查询。
	- IPC_SET:用于修改。---第三个给修改的内容---只可以修改部分，限权
	- IPC_RMID:用于删除。
	shmid_ds:结构体
11. 共享内存的缺点是多个进程同时写的时候，数据完全混乱了

#### 消息队列

1. 消息队列设计更加的合理，先把数据封入消息中，把消息队列。从队列中取出或放入数据。
2. 消息队列也是采用内存做交互媒介，系统内核管理一个队列，队列中存放着数据。
3. 消息队列的使用步骤：
	> 1. 用ftok()获得外部的key---不同IPC的key可以一样。相同的IPC不可以使用相同的key
	> 2. 用msgget()创建/获取 消息队列的ID
	> 3. 放入数据（msgsnd()） 或者 取出数据（msgrcv()）
	> 4. 如果确定不再使用消息队列，使用msgctl()删除队列
4. int msgget(key_t key,int magflg)
	> 返回miqid---就是队列
5. int msgsnd(int miqid,const void* msgp,size_t msgsz,int msgflg);
	> const void* msgp--->数据的首地址
6. ssize_t msgrcv(int msqid,void* msgp,size_t msgsz,long msgtyp,int msgflg);
    > size_t msgsz:期望的内存大小
    > msgtyp : 0---任意类型 队列 or >0---特定 or <0 ---消息结构中long的绝对值>0的从小到大
   	> msgflag:0--->阻塞；IPC_NOWAIT--->不等待
	> 返回读取数据的大小
7. 消息队列的正规用法：
	> 消息分为 有类型消息和无类型消息，无类型消息编程比较简单，但是接收数据时无法细分，只能先入先出。
	> 有类型消息比较规范，接收数据时可以区分，但不是先入先出。
	> 消息是一个结构，格式如下：
```
struct 结构名{  //结构名程序可以自定义
    long mtype;//消息类型，第一个成员必须是消息类型
    //数据区，支持任意类型的数据
    char date[1];
}
```
8. 把 结构 放入队列，或 从队列中取出。
9. msgsz 不带long的消息类型，msgp---带着long
10. int msgsnd(int msgid,void* addr,size_t size,int flag)
	> msgid就是消息的队列的ID,用key获取
	> addr就是消息的首地址，也就是消息类型的首地址
	> size就是消息中数据区的大小，不算消息类型。（算消息类型也可以）
	> flag 可以为0---阻塞，IPC_NOWAIT---非阻塞（满了直接返回-1）
11. ssize_t msgrcv(int msgid,void* addr,size_t size,int msgtype,int flag)
	> msgid和addr 与上相同
	> size就是接收buffer的大小
	> msgtype:决定了接收 何种类型的消息（消息类型必须大于0）
	> >0:接收 特定类型的消息
	> o: 接收 任意类型的消息
	> <0:接收类型是消息类型的绝对值小于等于msgtype的从小到大的数据
	> 成功返回实际接收到的字节数，失败返回-1
12. msgctl()---删除、查询
	> 和上面的共享内存一致
	> msgctl(msgid,IPC_RMID,0)
13. 注： 消息队列的删除而宏共享内存的删除机制不同，共享内存的删除只是做个删除标记，不确保马上删除，只有挂接数为0的才能被删除。
14. 消息队列随时可以删除，即使队列中还有消息依然会被删除
15. 软件公司的项目开发流程


























































































































