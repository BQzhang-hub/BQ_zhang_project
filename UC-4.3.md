# UC的文件管理

## 练习:

1. 只有字符/字符串类型才能看懂

## 练习

## 问题

1. 读写文件有两套函数，标C和UC，Unix系统下哪套效率高
2. time a.out可以查看程序的运行时间
3. UC函数在用户层没有输入输出的缓冲区，而标C函数有缓冲区
4. UC函数写一次就访问一次内核；标C函数先放入缓冲区，等缓冲区满了再访问一次内核。
5. 但是UC函数可以由 程序员 自定义缓冲区 ，从而大幅 提升效率

## 57

### 回顾

1. 文件的读写函数--open()、read()、write()、close()
2. 文件描述符和文件表--open()函数会打开一个文件，把文件的各种信息放入文件表 中，再去描述符总表中找到一个未使用的整数去对应这个文件表，这个整数就是文件描述符

### 43

1. 文件的其他函数-快速带过部分函数
2. 目录的操作

#### 文件的其他函数

1. lseek()---类似于fseek()，是fseek()的底层调用
//标C的体系是FILE*，UC是int fd;文件描述符
2. 文件指令和文件偏移量
3. off_t lseek(int fd,off_t offset,int whencr)
	>参数：fd 文件描述符
	> offset：偏移量
	> whence:偏移的起始位置，有三个值
		-SEEK_SET-从文件开始计算偏移
		-SEEk_CUR-从文件当前位置计算偏移
		-SEEK_END-从文件尾计算偏移
	> 返回：移动以后的位置和文件头的距离，失败返回-1
	> 注：这个返回值可以用来获取文件的大小。标C中要用fseek()+ftell()获取文件的大小
4. 使用VIM时，大多数情况下wq会自动加一个vim结束符，因此多一个字节
5. 经验：一般都使用SEEK_SET

----
6. dup()家族----复制文件描述符，不会复制文件表，出现多个描述符对应同一张文件表的情况
7. dup()是系统选择新的描述符的值（未使用的最小值）
8. dup2()是程序员指定新的描述符的值，如果指定的值已经被使用，会强制关闭后继续使用
9. 注：close()用于关闭文件描述符，不一定关闭文件表
10. close()其实就是在描述符总表移除对应关系，文件表的计数会减1，当文件表的计数到0，文件表就可以被回收

----

11. fcntl()--提供一些文件控制的功能
	> 文件描述符的复制，设置或者获取文件描述符和文件锁
12. int fcntl(int fd,int cmd,...);
	> 参数fd就是文件描述符，cmd是命令，...代表0-n个任意类型的参数
	> 返回和cmd的选择有关
	> cmd主要包括：
		- F_DUPED--复制文件描述符，需要传入第三个参数做新的描述符的值，如果这个值已经被使用，找 大于该值的未使用的最小值
		- F_SETFL/F_GETFL--设置/获取 文件描述符的状态，SETFL基本用不到，因为只能修改O_APPEND;GETFL不需要第三个参数，可以获取 权限和O_APPEND,创建标识无法获取
		- F_SETLK/F_SETLKW---设置文件锁


13. 经验：取二进制的某一位或某几位 用位与（&）1，比如取二进制的后8位：int a=1000;  a&0xff;//取后8位

----
14. 文件锁就是防止文件处理交叉覆盖，信息错误
15. 假如2个进程a，b,同时写入一个文件，就会产生相互影响的问题，解决方案就是使用文件锁。
16. 文件锁解决的就是多进程同时操作文件时产生数据冲突的问题。同一进程内部文件锁没有效果
17. 文件锁 允许 多个进程同时读，但是不允许同时写，有的读有的写也不行
18. 文件锁分为读锁和写锁。
19. 读锁针对于读操作，效果是允许其他进程读文件，但不允许写；写锁针对写操作，效果不允许其他进程读和写

----
20. 文件锁的使用是一个函数 +一个结构
21. fcntl()+struct flock
22. fcntl(int fd,F_SETLK/F_SETLKW,struct flock*);
23.
 
```struct flock{
       short l_type;//锁的类型，包括读锁、写锁和释放锁
	   short l_whence;//锁定起始点的参考位置
	   off_t l_strat;//锁定起始点的偏移量
	   off_t l_len;//锁定区域的大小，锁定的长度
	   pid_t l_pid;//锁定进程的PID,只有GETTLK时用，给-1即可

   };
```
   
24. l_type:F_RDLCK\F_WRLCK\F_UNLCK
25. l_whence:SEEK_END/SEEK_SET/SEEk_CUR
26. 注：文件锁不是锁定整个文件，而是锁定文件的一部分。锁定的部分由l_whence/l_strat和l_len三个联合决定
27. 比如：l_whence选SEEK_SET,l_strat=10,l_len=20;锁定区域就是：从第十一个到第30个
28. 文件锁其实并不能锁定 读写的函数read()/write().只能阻止其他进程的加锁行为，导致其他进程加不上锁
29. 正确用法是：在调用read()之前应该加上一个读锁，在调用write()之前加一个写锁，读写完毕记得马上释放锁
30. 锁定的方式有两种，一种是F_SETLK,锁定失败立即返回返回-1；另一种是F_SETLKW,锁不上就一直等待，等到别人释放后立即上锁。
31. F_GETLK--不是获得锁，是测试一个锁能不能加上，不会真的加锁
----
32. stat()/fstat()/lstat()---获取文件对应属性
33. stat()---可以获取文件在硬盘上的信息类似于 ls -il
34. i节点可以看成文件/目录在硬盘上的地址，ls -i可以查看i节点号
35. int stat(const char *pathname, struct stat *statbuf);
36. filename就是文件名
37. file就是结构体指针，用于传出文件的相关信息
38. struct stat 记录了文件的各种信息，效果等同于ls -l.其中st_size必须会，去文件的大小，其他的看手册即可
39. C语言关于时间的类型有两种：time_t(秒差记录时间和1970年1月1日 0点0分0秒的秒差)
40. struct tm年月日小时分秒的格式
41. localtime()可以实现秒差转结构功能
42. ctime()可以用美国时间的格式把秒差转换成时间字符串
43. man time.h
----
44. access()---可以更方便获取文件的权限，并且能判断文件是否存在。
45. access(int fd,mode);
46. moade:R_OK,W_OK,X_OK,F_OK//文件是否存在
47. 如果有权限返回0，没有返回-1，取得是当前用户的权限
----
*其他的常用函数
48. umask()
49. chown()---该权限
50. truncate()---指定文件的大小
51. remove---删除文件 或者 空目录
52. rename---文件 或者 目录 改名

----
# 回顾：

1. 文件的相关函数
2. lssek()移动文件读写的位置（文件偏移量）
3. dup()/dup2()复制文件描述
4. fcntl()-复制文件描述符、取/设文件描述符的状态，文件锁
5. 文件锁包括 读锁 和 写锁 自身不能锁定 读写操作，必须遵循调用函数之前写锁，读写完毕后需要释放锁的原则才有效果。
6. 文件锁只能阻止其他进程的加锁行为
7. 文件锁的添加方式可以分为阻塞（F_SETLK）和非阻塞（F_SETLKW）,文件锁用于多进程同时操作同一个文件的同一部分

# 今天

1. umask()--设置创建新文件时的 权限屏蔽字，对于修改文件权限时 权限屏蔽字没有效果。
2. umask()是在特殊情况下使用的，用chowd()其实也可以到达效果
3. umask()在使用完毕后需要恢复之前的权限屏蔽字。
4. 以新换旧，以旧换新
----
5. mmap()---映射硬盘文件
6. mmap(void* addr,size_t size,int prot,int flags,int std);

----
# 目录操作函数

1. mkdir()--创建一个空目录，mode参数指定权限\rmdir()---删除一个空目录
2. chdir()--切换当前的目录
3. getcwd()---获取当前工作目录的绝对路径形式（双返回）但是不打印
4. opendir()---打开一个目录
5. readdir()--读目录的内容（子项，子文件，子目录）
6. closedir()--关闭已打开的目录
7. 三个XXdir()---联合使用，实现读取目录中的内容
8. 信息储存在结构体中
9. 读取某个目录内容的步骤：
> opendir()返回目录指针
> 循环调用readdir(),逐一读取每个子项
> closedir()关闭目录，这步也可以省略
10. 递归特点：函数自己调用自己，注意：必须有退出条件。使用递归必须是简化问题，而不是复杂化问题
11. 注：这里复杂化包括两点  逻辑复杂化和效率复杂化
----

##  进程控制--58pm

1. 进程和程序的概念
2. 程序是硬盘的文件，是代码的编译连接产物
3. 运行起来的程序就是进程，进程是内存中运行的程序
4. 操作系统支持多进程的启动，每个进程内部支持多线程。
5. 进程之间是完全独立的。内存是独立的
6. 进程用进程ID唯一标识，叫PID,函数getpid()可以获取当前进程的ID
7. 查看进程的方式：window:ctrl+alt+delete启动任务管理器
8. Linux/unix 用ps命令查看进程。
9. ps 只能显示当前终端启动的进程
10. ps -aux | more:Linux专用选项，Uinx不直接支持(/usr/ucb/ps可以用);管道分页显示
11. ps -ef:unix/Linux通用的选项
12. 进程比较多 可以用管道 实现分页 ，命令：ps -aux|more
13. telnet IP远程登陆
14. whereis ps;
15. ps -ef：多一个ppid--父进程
16. ps可以查看进程的如下信息：
17. 进程PID、进程的启动者（属者）、CPU和内存使用率、状态、父进程的PID、启动的程序是哪个
18. 其中，进程的状态主要包括：
	> S---休眠状态,进程大多数处于休眠状态
    > s---说明该进程有子进程（父进程）
	> R---正在运行的进程
	> Z---僵尸进程（已经结束但是资源没有回收的进程）

19. 父进程与子进程
20. 操作系统中的多进程是有启动的次序的，Unix/Linux系统先系统先启动0进程，0进程再启动进程1和进程2（有些系统只启动进程1），然后0进程就休眠。
21. 进程1和进程2启动其他的进程，其他进程再启动其他的进程，直到所有进程都启动为止
22. 如果进程a启动了进程b,a叫b的父进程，b叫a的子进程。
----
23. 进程用PID表示，PID是一个非负整数，PID可以延迟重用
24. 计算机中启动时可以延迟启用
25. PID可以延迟重用。因此，PID在同一时刻保证唯一。 
----
26. 几个常用函数
27. getpid()---取当前进程的PID
28. getppid()---取当前进程的父进程的PID
29. getuid()---取当前用户的ID

----
30. 创建子进程的方法：
31. 1.fork()创建子进程，通过复制父进程创建子进程。因此父子进程对应相同的代码区
32. 2.vfork()+execl()创建子进程，父进程和子进程的代码区完全不同，父子进程执行的是完全不同的代码。
----
33. fork()是一个非常复杂的简单函数
34. pid_t fork();
35. 返回子进程的PID或者0，失败返回-1,没有参数。
36. fork()是通过复制父进程的内存空间创建子进程，复制除了代码区之外的所有区域，代码区父子进程共享（代码区只读性质实现共享）
37. fork()会创建一个子进程，子进程从fork()当前位置开始执行代码，fork()之前的代码父进程执行一次，fork()之后的代码父子进程分别执行一次（共2次）
38. fork()自身会返回两次，父进程返回子进程的PID,子进程会返回0；
39. fork()创建子进程时，会复制除了代码区之外的所有区域，包括缓冲区
40. fork()创建子进程时，如果父进程有文件描述符，子进程会复制文件描述符，不复制文件表（父子进程共用一个文件表）
----父子进程的关系
41. fork()创建子进程后，父子进程同时运行，如果子进程先结束，子进程会给父进程发信号后，父进程回收子进程的资源。
42. fork()创建子进程后，父子进程同时运行，如果父进程先结束，子进程变成孤儿进程，会认 进程1（init进程）做新的父进程，init进程也叫孤儿院。
43. fork()创建子进程后，父子进程同时运行，如果子进程结束时，子进程会给父进程发信后，父进程没有收到信号或者没及时处理，子进程就变成僵尸进程。
44. fork()创建子进程后，父子进程谁先运行不确定，谁先结束也不确定
45. fork()创建的子进程会复制父进程的虚拟内存地址，但是映射到不同的物理内存上，同时把原来的值拷贝过来。复制完成以后子进程的内存就独立了

-----59am

# 回顾

1. 目录操作---mkdir() rmdir() chdir() getcwd()
2. 进程管理---进程和程序的关系
3. 程序在硬盘中，要读取到内存中---变成进程
4. fork()--可以通过复制父进程创建子进程
5. vfork()+execl()创建和启动 全新的子进程
6. fork()除了代码区其他区全部复制
7. fork()复制文件描述符，不复制文件表
8. fork()复制缓冲区
9. fork()返会PID和0

# 59am

1. 进程的退出
----正常退出
2. 在main()中执行return语句
3. 执行exit()函数
4. 执行_Exit()或_exit()函数
5. 最后一个线程退出
6. 主线程退出
----非正常退出
7. 被信号打断导致退出
8. 最后一个线程被取消
9. exit()\_Exit()和_exit()都是用来退出进程的
10. 区别在于_Exit()和_exit()是一样的，区别在于头文件不同（uc/标C）
11. exit()和_Exit()区别主要在于退出方式的不同：
	> _Exit()是立即退出，exit()不是立即退出，还可以调用一些其他函数后再退出
	> 可以使用atexit()注册一些函数，这个函数在exit()之前会被自动调用，return也会调用
12. void exit(int status);status&0377---取后8位----0-255
13. 函数指针
14. void fs(void)---->void (*变量名)(void)
15. wait()和waitpid()
16. wait()和waitpid()可以让父进程等待子进程的结束，并取得子进程的退出状态和退出码（return后面的值或exit()的值）
17. wait()和waitpid()的区别在于wait()很固定，而waitpid()更灵活。
18. wait()是等待任意一个子进程的结束后返回，而waitpid()可以选择等待的子进程，也可以不等带
19. wait()可以等待僵尸子进程
20. pid_t wait(int* status)
21. 参数是一个传出参数，用来带出 结束子进程 结束的退出码和退出状态
22. 返回 有结束子进程 就返回它的PID,没有结束就等带，父进程自己阻塞，如果出了错 返回-1；
23. 宏函数WIFEXITED(status)可以判断是否注册退出
24. 宏函数WWEXITSTATUS(status)可以得到退出码
25. pid_t waitpid(pid_t pid,int *status,int options)
26. pid_t pid---可以指定等待多个pid
27. status---同上
28. options---选项
-----
29. pid的值
30. ==-1--- 等待任意子进程，与wait()等效
31. >0----- 等待指定子进程（指定pid）
32. ==0---- 等待本进程的任一子进程
33. <-1---- 等待进程组ID等于pid绝对值的任一 子进程
34. 后两种情况了解即可，比较少使用。
----
35. options的值：
36. 0-----阻塞
37. WNOHANG----不阻塞，直接返回0
----
38. 返回值：有子进程结束时返回子进程的PID
39. 出错返回-1
40. 如果阻塞方式 没有子进程结束继续等待
41. 如WNOHANG，没有子进程 返回0；







































































































































































