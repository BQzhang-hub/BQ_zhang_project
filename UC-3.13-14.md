# UC-3.13-14

## 回顾

1. 静态库和共享库
	- 共享库是.so文件，Linux系统提供大量的共享库文件
	- 通常情况下，没有主函数的代码会打包成共享库文件和头文件结合使用。
	- 头文件放变量、函数、宏、结构的声明
	- 库文件提供函数的实现（代码），变量的赋值
	
2. 错误处理
	- 依靠返回值代表错误
	- 返回值一般有4种情况
	- 需要将errer转换成错误信息

3. 环境表
4. 经验：用指针时，只提供首地址，大多数情况下需要知道结尾在哪里
5. 比如：字符串变量其实只是字符串的首地址，以\0结尾（不需要额外传入）
6. 数组其实就是首地址，以长度计算结尾。指针类型一般需要确定结尾

-----

## Unix/Linux的内存管理（操作系统的核心功能）

1. 关于进程的内存空间划分
2. 虚拟内存地址空间的机制
3. 内存管理的相关函数结构
4. 程序和进程
	 - 程序是代码编译链接的产物，是存储在硬盘上的文件，程序是静止的
	 - 运行起来的程序就是进程，是内存中运行的程序，也就是把程序加载到了内存中，是运行的
5. CPU不能直接访问硬盘，但是直接访问内存。程序必须加载内存中（变成了进程）才能真正运行起来
6. 有时候会把进程叫做程序，为了方便沟通。一个程序可以有多个进程
----
7. 进程的内存空间划分为以下部分：
	 - 代码区---用于存放代码（函数）的区域，是只读区。函数指针就是指向代码区的地址
	 - 全局区---用于存放全局变量（定义在函数外的变量）和static的局部变量的区域。
	 - BSS段----用于存放未初始化的***全局变量***的区域。BSS段在main()执行之前，会清0
	 - 栈区（堆栈区stack)----用于存放局部变量的区域，包括：函数的参数和非static的局部变量。系统自动管理栈区内存。
	 - 堆区（heap）---也叫自由区，程序员唯一可以控制的区域。通常内存分配、回收都是在堆区。malloc()\free()都是在堆区。堆区的内存，系统完全不管，程序员全权管理堆区内存
     - 只读常量区---存放字符串字面值（" "括起来的字符串）和const修饰的全局变量。这个区域也是只读区，很多书都把只读常量区并入代码区。

----

8. 虚拟内存地址空间的机制
	 - Unix/Linux使用虚拟内存地址的方式管理内存，每个进程先天都有0到4G-1的虚拟内存空间，本质就是整数（编号）
	 - 虚拟内存地址本身不能存储任何的数据，必须映射到物理内存或者硬盘的文件后才能存储数据，否则引发***段错误***
	 - 理论寻址最大空间---4位系统（2^4)
	 - 在虚拟时，不会做映射
	 - 对于所有的进程都是相同大小的物理内存，内存管理的时候保证循环利用，超过物理内存可以分块进行
9. 虚拟内存地址是分为用户层和内核层，用户层0~3G，3G~4G是内核层（可以设置）
10. 用户层不能直接访问内核层，可以通过系统函数
11. 内存的地址是一个字节一个字节的，物理内存不可以一个字节一个字节的映射
12. 内存的基本单位是字节，内存地址是逐字节的
13. 但是内存映射的基本单位不是一个字节，是4096个字节（4K），叫一个内存页
14. getpagesize()可以查看内存页的大小 

```
#include<stdio.h>
#include<string.h>
int i1 = 10;//全局
int i2;//BSS
static int i3 = 10;//全局
const int i4 = 10;//只读
void fa(int i5){//fa在代码区，i5在栈区
	int i6 = 10;//栈
	const int i7 = 10;//栈
	static int i8 = 10;//全局区
	char* s1 = "abc";//指向只读常量区
	int* pi = malloc(4);//堆区
	char s2[] = "abc";//指向栈，先声明在初始化，复制
	
	printf("i5=%p,i6=%p,i7=%p,i8=%p",s1=%p,s2=%p\n",&i5,&i6,&i7,&i8,s1,s2);
	free(pi);
}
int main(void){
	printf("i1=%p,i2=%p,i3=%p,i4=%p\n",&i1,&i2,&i3,&i4);
	fa(1);
	printf("fa=%p\,"fa);\\函数名就是函数指针
	return 0;
}

```
15. 进程的内存空间排列次序：（地址从小到大）
	- 代码区、只读常量区、全局区、BSS段、堆区、……栈
	- 栈从大到小、堆从小到大
16. 内存页---Linux系统中，几乎一切都做成了文件。目录是文件，内存也是文件，各种设备都是文件。
	- 内存中的每个进程，都在/proc目录下建立一个目录，目录名就是进程的ID(PID),进程结束目录就消失。
	- 这个目录就是进程的文件方式。cat /proc/PID/maps---查看进程的内存分配情况，getpid()可以获取当前进程的ID
	- 进程目录下的文件都是在内存，不占硬盘空间
----
17. 一个进程如果占用一个内存空间，另一个进程如果使用这个内存空间，出现段错误
18. 段错误的引发原因：
	- 使用没有映射的虚拟内存地址 存储/获取数据
	- 对内存区域进行没有权限的操作。比如：修改只读区
```
int *pi = NULL;
*pi->段错误；*pi没有映射的虚拟内存地址
```

----
19. C程序员的字符串
20. 字符串有三种形式：
	- 字面值("abc") \字符指针(char*) \字符数组(char a[])
	- 字符串必须有一个结尾'\0;结尾
	- 任何程序员字符串处理是基本功
***********关于字符串的基本操作string.c******
```
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
//字符串相关的基本操作
int main(void){
	//1.赋值，=改变的是指向的地址，strcpy()该地址的值
	char* s1="abc";//s1指向只读区
	char s2[10]="abc";

	s1 = "123"; //改变s1的指向，行
	strcpy(s1,"123");//改变只读区的值，不行

	s2 = "123";//数组是==常指针==，不能改指向
	strcpy(s2,123);//改变s2的值，不改指向
	
	char* ps = malloc(4);//ps指向堆区
	//!!!!ps = "abc";//可以出来但是不行,ps换指向了不行,这样就导致上面分配的内存无法释放
	//ps指向只读区，内存已经泄漏
	strcpy(ps,"abc");//可以并且行
	free(ps);
	
	//2字符串的长度和大小，strlen()取长度,'\0'不算长度
	char s3[10] = "abc";
	char* s4 = "abcdef";

	printf("sizeof(s3)=%d\n",sizeof(s3));//10
	printf("sizeof(s4)=%d\n",sizeof(s4));//4--指针

	printf("s3 length=%d\n",strlen(s3));//3
	printf("s4 length=%d\n",strlen(s4));//6//不加'\0'
	
	//3字符串的比较相等 ==和strcmp()的区别
	//==比的是地址，strcmp()比的是值
	//"abc"是只读区，所有在只读常量区内只有一份，所有*s5,*s6指向的是一份

	char* s5 = "abc";
	char* s6 = "abc";
	printf("%d\n",s5 == s6);//1--相等
	printf("%d\n,"strcmp(s5,s6));//0--相等
	char s5[] = "abc";
	char s6[] = "abc";
	printf("%d\n",s5 == s6);//0--相等
	printf("%d\n",strcmp(s5,s6));//0--相等
	
	//4字符串的拼接 strcpy()\strcat()\sprintf()
	char *s7 = "zhangfei";
	char *s8 = "feifei123"
	strcat(s7,s8);//不行
	char buf[40]={};
	/*strcpy(buf,s7);
	strcat(buf,",");
	strcat(buf,s8);*/
	
	sprintf(buf,"%s,%s",s7,s8);//打印到字符串中
	
	printf("buf=%s",buf);	
	
	//5  用指针的方式操作字符串
	char s9 = "abcanbdjhaaaa";//判断有几个a
	int count = 0;
	while(*s9){
		if(*s9 == 'a'){
			++count;
			++s9;
		}
		printf("count=%d\n",count);
	}
	
	// 拆分buf成用户和密码,指针
	char name[20]={};
	char passwd[20]={};
	/*int pos = 0;
	while(*(buf+pos)!=',')
		++pos;
	memcpy(name,buf,pos);//按n拷贝字符串
	strcpy(passwd,buf+pos+1);*/

	sscanf(buf,"%s,%s",name,passwd);//部分有效
	printf("name=%s;passwd=%s",name,passwd);
	
	//6 字符串和其他类型的转换（int/double）
	int x = 10;  //atoi();"10";x=9,x+'0'->'9'
	//sprintf();sscnf()
	char buf1[12]={};
	sprintf(buf,"%d",x);//其他类型--->字符串
	printf("buf1=%s\n",buf1);
	
	int y =0;
	sscanf(buf1,"%d",&y);//字符串--->其他类型
	printf("%d\n",y);
	return 0;
	
}

```
----
21. 内存管理的相关函数结构
	- STL容器---全自动管理（c++后期）
		|
	- C++---new分配，delete回收内存
		|
	- C语言--malloc(),free()
		|
	- Unix系统函数--sbrk()/brk()分配和回收内存
		|
	- Unix系统函数---mmap()映射物理内存/硬盘文件---munmap()解除映射
（用户函数到此为止）
----
22. Unix内核层函数---kmalloc()/vmalloc()(内核层，嵌入式)
