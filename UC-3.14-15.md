# UC-3.14-15

## 回顾

1. Unix的内存管理
2. 虚拟内存地址空间、进程的内存空间划分、内存管理的相关函数
3. 程序员接触到的都是虚拟内存地址，不是真实的物理内存地址
4. 虚拟内地址每个进程都是先天具有的，本质是一个编号（整数）自身不能存储任何的数据
5. 虚拟内存地址只有映射到物理内存或硬盘文件之后才能存储数据，否则就引发段错误
6. 虚拟内存地址中，0-3G属于用户，叫用户空间，3-4G属于内核，叫做内核空间
7. 用户空间不能直接访问内核空间，可以通过系统提供的一系列函数（系统调用System call）进入内核空间。内存的分配是按字节进行的，但是内存的映射按内存页进行的
8. 进程的内存分配划分--代码区、只读常量区、全局区、BSS段、堆区、栈区 

## 内存管理的相关函数（主要针对堆区）

### malloc()和free()

1. malloc()--传入分配内存的大小（字节）。返回分配内存的首地址。
2. 内存分配的函数干两件事：分配虚拟内存地址（所有情况下）、映射物理内存/硬盘文件（第一次映射，后面用完了再映射）
3. malloc()申请小块内存时 一次映射33个内存页，用完后继续映射
4. 申请大块内存时（超过31个内存页）会映射比申请稍多一点的内存页
5. 
```
int main(){
	int x = 10;
	int* x = malloc(10240*4);//内存过大，循环利用
	...
	//x用完
	free(x);
	...
	return 0;
}
```
6. int* pi = malloc(4/8/16/32);
	free(pi);//pi是首地址，没有结束信息，何时结束？
	malloc()除了分配正常的内存空间，还需要额外开辟一些空间，用于存储一些附加信息，比如分配的大小。存在前面4个字节
```
  1 #include<stdio.h>
  2 #include<stdlib.h>
  3
  4 int main(void){
  5         int a,b,c,d;
  6         printf("a=%p,b=%p,c=%p,d=%p\n",&a,&b,&c,&d);
  7         int* p1 = malloc(4);
  8         int* p2 = malloc(4);
  9         int* p3 = malloc(4);
 10         printf("p1=%p,p2=%p,p3=%p",p1,p2,p3);
 11         //*(p1-1) = 0;//清P1前4个内容，报错
 12         //*(p+100) = 10;//未分配内存，但是没有超过上面分配的内存页，已映射，也要分配内存
 13         //free(p1);//要保证内存是完整的
			free(p2);
			free(p3);
			int* p4=malloc(4);//收了虚拟地址
 14         return 0;
 15
 16 }
 
```

7. 图--malloc()
8. malloc()在使用时不需要考虑那么多，正常使用即可。
 
----

9. free()
10. free()不解除映射少于33个内存页
11. free()一定会释放虚拟内存地址，以便虚拟内存地址可以循环利用，不一定解除映射。
12. 超过33个内存页的部分会释放，最后33个内存页不释放，直到进程结束时释放。
13. 进程结束内存完全释放

----

### brk()和sbrk()--Unix系统函数

1. #include<unistd.h>
2. void* sbrk(intptr_t increment);//_t:整数或结构
3. incremet:增量---正数：分配；0:当前位置；负数：释放
	- 返回移动之前的位置（可用内存的首地址），这个返回值对于增量为负数的情况没有意义
4. sbrk()和brk()--系统的底层会维护一个位置，通过位置的移动完成内存的分配和回收。
5. 映射内存时以一个内存页作为基本单位
6. 位置---图.位置
7. man sbrk();---(void*) -1----把整数看成指针
8.
```
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>

int main(void){
	printf("pid = %d\n",getpid());
	void* p1 = sbrk(4);//返回00，位置在04
	if(p1 == (void*)-1){
		perror("sbrk");
		exit(-1);
	}
	printf("p1=%p\n",p1);
	sleep(10);
	printf("sleep over\n");
	int* pi1 = p1;//类型转换
	int* pi2 = sbrk(4);//返回04，位置在08
	int* pi3 = sbrk(4);//返回08，位置在12
	printf("pi2=%p,pi3=%p\n",pi2,pi3);
	sleep(10);
	sbrk(-4);//位置08
	sbrk(-4);//位置04
	int* pi4 = sbrk(0);//当前位置
	sbrk(4093);//4093+4=4097 超了一页,映射2页
	sleep(10);
	printf("sleep\n");
	sbrk(-1);//回到一页，立即回收
	sleep(10);
	sbrk(4092);
	return 0; 

}



```
9. sbrk()在分配内存时很方便，但是在回收时比较麻烦；
10. brk()则相反
11. 开发中，一般用sbrk()分配内存，用brk()回收内存。

----
12. int brk(void* addr); //直接指定新位置
13. 使用方式就是直接传递一个地址过来，做新的位置。
14. brk()必须和sbrk()结合使用，获得第一个位置。


-----

# 3-18啦

# 3-30啦---哈哈哈哈哈---加油啊

1. mmap()和munmap()--Unix的系统函数，更贴近底层
2. void *mmap(void *addr, size_t length, int prot,int flags,int fd, off_t offset);
	> 参数addr可以指定映射的首地址，一般为NULL 交给内核指定
	> size就是分配内存的大小，映射时以页为单位
	> port是分配内存的权限，一般用PORT_READ|PORT_WRITE
	> flags是标识，通常包括以下三个
		MAP_SHARED MAP_PRIVATE:二选一，指明映射的内存是否共享，
		MAP_SHARED只对映射文件有效
		MAP_ANONYMOUS:映射物理内存，默认映射文件
	> fd是文件描述符，在映射文件时有用
	> offest是文件的偏移量，指定映射文件时从哪里开始
	> 映射物理内存时，fd和offset给0即可
	> 返回成功返回首地址，失败返回MAP_FAILED==(void*)-1

3. 位运算符----权限
> 100--读权限
> 010--写权限
> 001--执行权
-------
> 111---7
> chmod 777 a.txt

4. 经验：如果有多个权限、选项的拼接，一般设计的方式就是：每种权限、选项用一个二进制表示（一位是1，其他全0），用位或运算连起来
5. 对于函数的选择，具体问题具体分析
6. 系统调用
> 用户层的程序 不能 直接访问内核层 系统的核心功能必须通过内核层控制
> 因此，系统提供了一系列的函数 允许用户层的程序通过 函数进入内核层，从而完成功能。这些函数叫做系统调用（System call）

























































